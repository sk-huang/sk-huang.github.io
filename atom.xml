<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sk&#39;blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T08:49:21.617Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin函数的默认参数和命名参数</title>
    <link href="http://yoursite.com/2017/12/13/2017-12-13/"/>
    <id>http://yoursite.com/2017/12/13/2017-12-13/</id>
    <published>2017-12-13T02:54:57.000Z</published>
    <updated>2017-12-13T08:49:21.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>函数的参数可以有默认值，使用 <code>=</code> 定义默认值。</p>
<p>如：</p>
<pre><code class="kotlin">fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = &#39; &#39;) {

}
</code></pre>
<p>后面4个参数都有默认值，如果后面参数使用默认值，则可直接使用 <code>reformat(&quot;test&quot;)</code> 调用</p>
<p>当覆盖一个父类的方法时，总是使用父类的默认参数值。当覆盖一个带有默认值参数的父类方法时，必须从参数中省略默认的参数值：</p>
<pre><code class="kotlin">open class A {
    open fun test(i: Int = 10) { …… }
}

class B : A() {
    override fun test(i: Int) { …… } // 不能有默认值
}
</code></pre>
<h3 id="命明参数"><a href="#命明参数" class="headerlink" title="命明参数"></a>命明参数</h3><p>可以在调用函数时，使用命名的函数参数。</p>
<p>如：</p>
<pre><code class="java">fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean ,
             wordSeparator: Char = &#39; &#39;) {

}
</code></pre>
<p>第一个和第四个参数没有默认值，可以这样调用:</p>
<pre><code class="kotlin">reformat(str = &quot;a&quot;, normalizeCase = false, upperCaseFirstLetter = false, divideByCamelHumps = false, wordSeparator = &#39;b&#39;)
</code></pre>
<p>如果有想省略的参数可以这样调用：</p>
<pre><code class="kotlin">reformat(&quot;a&quot;, divideByCamelHumps = false)
</code></pre>
<p>如果一个默认参数在一个无默认值参数的前面，那么想使用改默认值只能通过 <strong>命名参数</strong> 调用：</p>
<pre><code class="kotlin">fun foo(bar: Int = 0, baz: Int) { /* …… */ }

foo(baz = 1) // 使用默认值 bar = 0
</code></pre>
<p>当一个函数调用混用位置参数与命名参数时，所有位置参数都要放在第一个命名参数之前。</p>
<p>例如：</p>
<pre><code>fun f(x: Int = 1, z: Int = 1, y: Int) {}

f(1, y = 2)  //允许
f(x = 1, 2)  //报错
f(x = 1, y = 2) //允许
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>使用命名参数和默认参数可以很好的<strong>减少重载函数的数量</strong>，使代码更少更容易阅读</li>
<li>在调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不总是保留函数参<br>数的名称</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h3&gt;&lt;p&gt;函数的参数可以有默认值，使用 &lt;code&gt;=&lt;/code&gt; 定义默认值。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code 
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
      <category term="命名参数" scheme="http://yoursite.com/tags/%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>databinding 自定义方法</title>
    <link href="http://yoursite.com/2017/12/07/2017-12-7/"/>
    <id>http://yoursite.com/2017/12/07/2017-12-7/</id>
    <published>2017-12-07T07:54:57.000Z</published>
    <updated>2017-12-07T07:12:24.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-BindingAdapter注解"><a href="#使用-BindingAdapter注解" class="headerlink" title="使用@BindingAdapter注解"></a>使用@BindingAdapter注解</h3><p>如下：</p>
<p>java版：</p>
<pre><code class="java">@BindingAdapter({&quot;bind:imageUrl&quot;})
public static void display(ImageView iv, String url) {
    Toast.makeText(iv.getContext(), &quot;_&quot; + url, Toast.LENGTH_SHORT).show();
    Glide.with(iv.getContext()).load(url).into(iv);
}
</code></pre>
<p>kotlin版： (<strong>kotlin的companion object并不是真正的static，，在运行是他仍是实例对象的实例成员，而BindingAdapter需要一个真正的static，在jvm平台可以使用JvmStatic注解，使它成为一个真正的static</strong>)</p>
<pre><code class="kotlin">companion object {
    @BindingAdapter(&quot;bind:imageUrl&quot;)
    @JvmStatic
    fun displayIma(iv: ImageView, url: String) {
        Toast.makeText(iv.context, &quot;_&quot; + url, Toast.LENGTH_SHORT).show()
        Glide.with(iv.getContext()).load(url).into(iv);
    }
}
</code></pre>
<p>然后在任意 xml 中引用 bind 的方法即可，只有当前 BindingAdapter 绑定的参数个数都满足才会触发(<strong>这里的 <code>bind:imageUrl</code> 中 bind 可以任意命名，xml可以不一致，主要是后面的参数名要一致</strong>)<br>xml：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;

    &lt;data&gt;

        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;&gt;&lt;/variable&gt;

    &lt;/data&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;android.support.constraint.ConstraintLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/imageView1&quot;
                android:layout_width=&quot;247dp&quot;
                android:layout_height=&quot;50dp&quot;
                android:contentDescription=&quot;iv1&quot;
                app:imageUrl=&quot;@{list[0]}&quot;
                app:layout_constraintEnd_toEndOf=&quot;parent&quot;
                app:layout_constraintHorizontal_bias=&quot;0.5&quot;
                app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt;
        &lt;/android.support.constraint.ConstraintLayout&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;
&lt;/layout&gt;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用-BindingAdapter注解&quot;&gt;&lt;a href=&quot;#使用-BindingAdapter注解&quot; class=&quot;headerlink&quot; title=&quot;使用@BindingAdapter注解&quot;&gt;&lt;/a&gt;使用@BindingAdapter注解&lt;/h3&gt;&lt;p&gt;如下
    
    </summary>
    
      <category term="databinding" scheme="http://yoursite.com/categories/databinding/"/>
    
    
      <category term="databinding" scheme="http://yoursite.com/tags/databinding/"/>
    
  </entry>
  
  <entry>
    <title>使用DataBinding总结（一）</title>
    <link href="http://yoursite.com/2017/12/05/2017-12-5/"/>
    <id>http://yoursite.com/2017/12/05/2017-12-5/</id>
    <published>2017-12-05T07:54:57.000Z</published>
    <updated>2017-12-07T07:10:56.863Z</updated>
    
    <content type="html"><![CDATA[<p>1 .  xml 除 <code>java.lang.*</code> 的类，其他所有的用到的类都需要导入<br>2 .  事件处理有两种方式：</p>
<ul>
<li>方法引用 ： <code>引用所在类名::方法名</code> (<strong>使用该方法xml中调用的方法名签名必须和实际接口方法名签名一致，即参数类型，个数，返回类型一致</strong>)</li>
</ul>
<pre><code class="java">public class MyHandlers {
    public void onClickFriend(View view) { ... }
}  

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
   &lt;data&gt;
       &lt;variable name=&quot;handlers&quot; type=&quot;com.example.MyHandlers&quot;/&gt;
       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;
   &lt;/data&gt;
   &lt;LinearLayout
       android:orientation=&quot;vertical&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;&gt;
       &lt;TextView android:layout_width=&quot;wrap_content&quot;
           android:layout_height=&quot;wrap_content&quot;
           android:text=&quot;@{user.firstName}&quot;
           android:onClick=&quot;@{handlers::onClickFriend}&quot;/&gt;
   &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<ul>
<li>事件绑定： 使用 lambda表达式(<strong>只要方法返回的类型一样就行，可以扩展参数</strong>)  下例中使用<code>(v) -&gt; activity.removeList()</code>去调用，如果没用到v的话可以省略，即 <code>() -&gt; activity.removeList()</code> 左侧括号里的参数是super向下传递的参数</li>
</ul>
<pre><code class="java">//Activity
fun removeList() {

} 
//xml
&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;
&lt;data&gt;
    &lt;variable
        name=&quot;v&quot;
        type=&quot;android.view.View&quot;&gt;&lt;/variable&gt;
    &lt;variable
        name=&quot;activity&quot;
        type=&quot;com.android.sk.databidingtest.bind.ListActivity&quot;&gt;&lt;/variable&gt;
&lt;/data&gt;

&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;Button
        android:id=&quot;@+id/bt_change_value&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:onClick=&quot;@{() -&gt; activity.removeList()}&quot;
        android:text=&quot;改变list&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;0.5&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/rv&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_constraintEnd_toEndOf=&quot;@+id/bt_change_value&quot;
        app:layout_constraintStart_toStartOf=&quot;@+id/bt_change_value&quot;
        app:layout_constraintTop_toBottomOf=&quot;@+id/bt_change_value&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt;
&lt;/android.support.constraint.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
<p>3 .  在databinding中增加任何方法或者属性时，最好先compile一下，避免不自动生成</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1 .  xml 除 &lt;code&gt;java.lang.*&lt;/code&gt; 的类，其他所有的用到的类都需要导入&lt;br&gt;2 .  事件处理有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法引用 ： &lt;code&gt;引用所在类名::方法名&lt;/code&gt; (&lt;strong&gt;使用该方法xml中调
    
    </summary>
    
      <category term="databinding" scheme="http://yoursite.com/categories/databinding/"/>
    
    
      <category term="databinding" scheme="http://yoursite.com/tags/databinding/"/>
    
  </entry>
  
  <entry>
    <title>kotlin for android (五)</title>
    <link href="http://yoursite.com/2017/11/24/2017-11-24/"/>
    <id>http://yoursite.com/2017/11/24/2017-11-24/</id>
    <published>2017-11-24T07:54:57.000Z</published>
    <updated>2017-12-05T11:03:58.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是将函数作为参数或者返回值的函数。 </p>
<p>有一个很好的例子就是在多线程中，接收一个锁对象和一个函数，获取锁，运行函数，释放锁</p>
<p>实例：</p>
<pre><code class="kotlin">val lock = ReentrantLock()
fun toBeSync(){

}
lock(lock, ::toBeSync)
</code></pre>
<pre><code class="kotlin">fun &lt;T&gt; lock(lock: Lock, bod: () -&gt; T): T {

    lock.lock()
    try {
        return bod()
    } finally {
        lock.unlock()
    }
}
</code></pre>
<p>调用还可以使用lambda表达式</p>
<pre><code class="kotlin">lock(lock, {
            //doing
        })
</code></pre>
<h3 id="关于Lambda"><a href="#关于Lambda" class="headerlink" title="关于Lambda"></a>关于Lambda</h3><ul>
<li>lambda 表达式总是被大括号括着；</li>
<li>其参数（如果有的话） 在 -&gt; 之前声明（参数类型可以省略） ；</li>
<li>函数体（如果存在的话） 在 -&gt; 后面。</li>
</ul>
<p>在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达<br>式作为相应的参数，你可以在圆括号之外指定它：</p>
<p>Lambda 表达式:</p>
<pre><code class="kotlin"> lock(lock) {
            //doing
        }
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h3&gt;&lt;p&gt;高阶函数是将函数作为参数或者返回值的函数。 &lt;/p&gt;
&lt;p&gt;有一个很好的例子就是在多线程中，接收一个锁对象和一个函数，获取锁
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin for android (四)</title>
    <link href="http://yoursite.com/2017/11/23/2017-11-23/"/>
    <id>http://yoursite.com/2017/11/23/2017-11-23/</id>
    <published>2017-11-23T07:54:57.000Z</published>
    <updated>2017-12-05T11:02:19.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实用方法与技巧"><a href="#实用方法与技巧" class="headerlink" title="实用方法与技巧"></a>实用方法与技巧</h2><h3 id="Say-Goodbye-to-findViewById"><a href="#Say-Goodbye-to-findViewById" class="headerlink" title="Say Goodbye to findViewById"></a>Say Goodbye to findViewById</h3><ol>
<li>在根目录的gradle文件中应用extensions插件 <pre><code>apply plugin: &#39;kotlin-android-extensions&#39;
</code></pre></li>
<li>sync后就可以直接import当前的xml属性 <pre><code class="kotlin">import kotlinx.android.synthetic.main.activity_test1.*
</code></pre>
</li>
<li>使用如下<pre><code>//class
import kotlinx.android.synthetic.main.activity_test1.*
class TestKtActivity : AppCompatActivity() {
 override fun onCreate(savedInstanceState: Bundle?) {
     super.onCreate(savedInstanceState)
     setContentView(R.layout.activity_test1)
     tvText.text = &quot;test&quot;
 }
}
//xml
&lt;Button
         android:id=&quot;@+id/tvText&quot;
         android:layout_width=&quot;wrap_content&quot;
         android:layout_height=&quot;wrap_content&quot;
         android:layout_gravity=&quot;center&quot;
         android:text=&quot;hello，这是kotlin 测试&quot; /&gt;
</code></pre></li>
</ol>
<h3 id="分离java文件和kotlin文件"><a href="#分离java文件和kotlin文件" class="headerlink" title="分离java文件和kotlin文件"></a>分离java文件和kotlin文件</h3><ol>
<li>在java文件夹同级目录创建kotlin文件夹<br><img src="https://i.imgur.com/hsmAQWa.png" alt="分离文件层级"></li>
<li>在主module目录下的gradle文件中添加 <pre><code class="gradle">sourceSets{
     main.java.srcDirs += &quot;src/main/kotlin&quot;
 }
</code></pre>
</li>
</ol>
<h3 id="使用KotlinByteCode查看当前kotlin的生成源码"><a href="#使用KotlinByteCode查看当前kotlin的生成源码" class="headerlink" title="使用KotlinByteCode查看当前kotlin的生成源码"></a>使用KotlinByteCode查看当前kotlin的生成源码</h3><p>Tools -&gt; Kotlin -&gt; KotlinByteCode， 在相应的kt文件点击decompile，可以知道当前<code>.kt</code>生成的 java 语句是否正确</p>
<h3 id="使用插件自动将json转化pojo类"><a href="#使用插件自动将json转化pojo类" class="headerlink" title="使用插件自动将json转化pojo类"></a>使用插件自动将json转化pojo类</h3><p>plugin -&gt; JsonToKotlinClass</p>
<h3 id="关键字、字符意义对照表"><a href="#关键字、字符意义对照表" class="headerlink" title="关键字、字符意义对照表"></a>关键字、字符意义对照表</h3><p><a href="https://kotlinlang.org/docs/reference/keyword-reference.html" target="_blank" rel="external">https://kotlinlang.org/docs/reference/keyword-reference.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实用方法与技巧&quot;&gt;&lt;a href=&quot;#实用方法与技巧&quot; class=&quot;headerlink&quot; title=&quot;实用方法与技巧&quot;&gt;&lt;/a&gt;实用方法与技巧&lt;/h2&gt;&lt;h3 id=&quot;Say-Goodbye-to-findViewById&quot;&gt;&lt;a href=&quot;#Say-Go
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin for android (三)</title>
    <link href="http://yoursite.com/2017/11/22/2017-11-22/"/>
    <id>http://yoursite.com/2017/11/22/2017-11-22/</id>
    <published>2017-11-22T07:54:57.000Z</published>
    <updated>2017-12-07T06:30:27.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="standard库几个特殊的系统函数"><a href="#standard库几个特殊的系统函数" class="headerlink" title="standard库几个特殊的系统函数"></a>standard库几个特殊的系统函数</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote>
<p>函数定义- <code>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block(); return this }</code></p>
<p>使用对象调用<code>apply</code>，可以在方法中使用<code>this</code>指代当前对象，可以省略。返回值为<strong>当前对象</strong></p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    val array =  arrayList.apply {
        add(&quot;d&quot;)
        add(&quot;e&quot;)
        remove(&quot;a&quot;)
        println(this)  //[b, c, d, e]
    }
    println(arrayList) //[b, c, d, e]
    println(array)  //[b, c, d, e]
</code></pre>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote>
<p>函数定义- <code>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</code></p>
<p>使用对象调用let函数，在函数内可以使用<code>it</code>指代当前对象, 不可省略。返回值为<strong>最后一句</strong>或者指定的<strong>return表达式</strong></p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    arrayList.let {
        it.add(&quot;d&quot;)
        return@let
        it.add(&quot;e&quot;)
        it.remove(&quot;a&quot;)
        println(this)
    }
    println(&quot;$arrayList&quot;)   //[a, b, c, d]
</code></pre>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><blockquote>
<p>函数定义- <code>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</code></p>
<p><code>with</code>不是以对象的扩展函数存在，它是把对象当成参数来使用。在函数内使用<code>this</code>指代当前对象，可以省略。返回值为<strong>最后一句</strong>或者指定的<strong>return表达式</strong></p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    val str = with(arrayList) {
        add(&quot;d&quot;)
        return@with &quot;array&quot;
        add(&quot;e&quot;)
        remove(&quot;a&quot;)
        println(this)
    }
    println(&quot;$arrayList&quot;)  //[a, b, c, d]
    println(&quot;$str&quot;)   //array
</code></pre>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>run函数有两种一种是对象的扩展，一种是无对象</p>
<h5 id="有对象调用的run"><a href="#有对象调用的run" class="headerlink" title="有对象调用的run"></a>有对象调用的run</h5><blockquote>
<p>函数定义- <code>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</code></p>
<p>使用对象调用<code>run</code>函数，在函数内使用<code>this</code>指代当前对象，可以省略。返回值为<strong>最后一句</strong>或者指定的<strong>return表达式</strong> </p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    val str = arrayList.run{
        add(&quot;d&quot;)
        return@run &quot;array&quot;
        add(&quot;e&quot;)
        remove(&quot;a&quot;)
        println(this)
    }
    println(&quot;$arrayList&quot;)  //[a, b, c, d]
    println(&quot;$str&quot;)  //array
</code></pre>
<h5 id="无对象调用的run"><a href="#无对象调用的run" class="headerlink" title="无对象调用的run"></a>无对象调用的run</h5><blockquote>
<p>函数定义- <code>public inline fun &lt;R&gt; run(block: () -&gt; R): R = block()</code></p>
<p>直接调用<code>run</code>函数，在函数内不能使用关键字指代当前对象。返回值为<strong>最后一句</strong>或者指定的<strong>return表达式</strong>  </p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin"> var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    val str = run {
        arrayList.add(&quot;d&quot;)
        return@run &quot;array&quot;
        arrayList.add(&quot;e&quot;)
        arrayList.add(&quot;a&quot;)
        println(this)
    }
    println(&quot;$arrayList&quot;)  //[a, b, c, d]
    println(&quot;$str&quot;)  //array
</code></pre>
<h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><blockquote>
<p>kotlin 1.1以后新增</p>
<p>函数定义- <code>public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { block(this); return this }</code></p>
<p>使用对象调用<code>also</code>函数，在函数内使用<code>it</code>指代当前对象，不能省略。返回值为<strong>当前对象</strong></p>
</blockquote>
<p>实例：</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)

    val str = arrayList.also {
    it.add(&quot;d&quot;)
    return@also
    it.add(&quot;e&quot;)
    it.add(&quot;a&quot;)
    }
    println(&quot;$arrayList&quot;)  //[a, b, c, d]
    println(&quot;$str&quot;)  //[a, b, c, d]
</code></pre>
<h3 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a>takeIf</h3><blockquote>
<p>kotlin 1.1以后新增</p>
<p>函数定义- <code>public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? = if (predicate(this)) this else null</code></p>
<p>使用对象调用<code>takeIf</code>函数，在函数内使用<code>it</code>指代当前对象，不能省略。返回值根据<strong>最后一句话的boolean值</strong>或者<strong>return表达式返回的boolean值</strong>，如果<strong>true</strong>，返回<strong>当前对象</strong>，如果<strong>false</strong>，返回<strong>null</strong></p>
</blockquote>
<p>实例 </p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)
    val takeIf = arrayList.takeIf {
        it.add(&quot;e&quot;)
        return@takeIf false
        it.remove(&quot;f&quot;)
    }
    println(&quot;$takeIf&quot;) //null
</code></pre>
<h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><blockquote>
<p>函数定义- <code>public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? = if (!predicate(this)) this else null</code></p>
<p>和takeIf一样，只是返回值判断有所不同。返回值如果<strong>false</strong>，返回<strong>当前对象</strong>，如果<strong>true</strong>，<strong>null</strong></p>
</blockquote>
<p>实例</p>
<pre><code class="kotlin">var arrayList = ArrayList&lt;String&gt;()
    arrayList.add(&quot;a&quot;)
    arrayList.add(&quot;b&quot;)
    arrayList.add(&quot;c&quot;)
    val takeIf = arrayList.takeUnless {
        it.add(&quot;e&quot;)
        return@takeUnless false
        it.remove(&quot;f&quot;)
    }
    println(&quot;$takeIf&quot;) //[a, b, c, e]
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;standard库几个特殊的系统函数&quot;&gt;&lt;a href=&quot;#standard库几个特殊的系统函数&quot; class=&quot;headerlink&quot; title=&quot;standard库几个特殊的系统函数&quot;&gt;&lt;/a&gt;standard库几个特殊的系统函数&lt;/h2&gt;&lt;h3 id=&quot;a
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin for android (二)</title>
    <link href="http://yoursite.com/2017/11/21/2017-11-21/"/>
    <id>http://yoursite.com/2017/11/21/2017-11-21/</id>
    <published>2017-11-21T07:54:57.000Z</published>
    <updated>2017-12-07T06:37:29.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>app开发一个简单的功能，流程基本是： 渲染ui-&gt;请求网路-&gt;解析数据-&gt;设置ui控件</p>
</blockquote>
<h2 id="创建一个activity"><a href="#创建一个activity" class="headerlink" title="创建一个activity"></a>创建一个activity</h2><pre><code class="kotlin">class TestKtActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_test1)
    }

    override fun onStart() {
        super.onStart()
    }

    override fun onStop() {
        super.onStop()
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
</code></pre>
<h2 id="创建一个接口类"><a href="#创建一个接口类" class="headerlink" title="创建一个接口类"></a>创建一个接口类</h2><pre><code class="kotlin">//interface
interface TestImpl {
    fun a()
    fun b(str: String)
}
</code></pre>
<pre><code class="kotlin">//class
class TestKtActivity : AppCompatActivity(), TestImpl {
    override fun b(str: String) {
        TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.
    }
    override fun a() {
        TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_test1)
        tvText.text = &quot;test&quot;
    }
}
</code></pre>
<p>如果实现了多个接口，方法有重名的冲突。解决如下：</p>
<pre><code class="kotlin">interface A {
    fun foo() { print(&quot;A&quot;) }
    fun bar()
}

interface B {
    fun foo() { print(&quot;B&quot;) }
    fun bar() { print(&quot;bar&quot;) }
}

class C : A {
    override fun bar() { print(&quot;bar&quot;) }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super&lt;B&gt;.bar()
    }
}
</code></pre>
<h2 id="创建一个抽象类（基类）"><a href="#创建一个抽象类（基类）" class="headerlink" title="创建一个抽象类（基类）"></a>创建一个抽象类（基类）</h2><pre><code class="kotlin">abstract class BaseActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(getLayout())
        init()
    }


     @LayoutRes abstract fun getLayout(): Int

    private fun init() {
        initListener()
        initData()
    }

    abstract fun initListener()
    internal abstract fun initData()

    override fun onStart() {
        super.onStart()
    }
}
</code></pre>
<p>默认所有的类和成员属性都是final类型，如果想让该类被继承，可以使用<code>open</code>关键字<br>Example:</p>
<pre><code class="kotlin">open class Outer {
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4  // public by default

    protected class Nested {
        public val e: Int = 5
    }
}

class Subclass : Outer() {
    // a is not visible
    // b, c and d are visible
    // Nested and e are visible

    override val b = 5   // &#39;b&#39; is protected
}

class Unrelated(o: Outer) {
    // o.a, o.b are not visible
    // o.c and o.d are visible (same module)
    // Outer.Nested is not visible, and Nested::e is not visible either 
}
</code></pre>
<h2 id="创建一个pojo类"><a href="#创建一个pojo类" class="headerlink" title="创建一个pojo类"></a>创建一个pojo类</h2><pre><code class="kotlin">data class ktTest3(val name: String = &quot;&quot;, var pwd: String = &quot;&quot;, private var gender: String)
</code></pre>
<blockquote>
<ul>
<li>定义为<code>data</code>的类会自动实现<code>getter()</code>、<code>setter()</code>、<code>toString()</code>、<code>hashcode</code>等方法</li>
<li>如果属性修饰为<code>val</code>只读属性，只会生成<code>getter()</code>方法</li>
<li>如果属性修饰为<code>var</code>，会生成<code>getter()</code>、<code>setter()</code></li>
<li>如果属性权限使用<code>private</code>，将不会生成<code>getter()</code>、<code>setter()</code>方法</li>
</ul>
</blockquote>
<h2 id="通过Gson反序列化"><a href="#通过Gson反序列化" class="headerlink" title="通过Gson反序列化"></a>通过Gson反序列化</h2><pre><code class="kotlin">data class ktTest3(val name: String=&quot;&quot;, val pwd: String=&quot;&quot;) {
    override fun toString(): String {
        return &quot;ktTest3(name=&#39;$name&#39;, pwd=&#39;$pwd&#39;)&quot;
    }
}
</code></pre>
<pre><code class="kotlin"> val g = Gson()
 val k = g.fromJson(
                &quot;{\n&quot; +
                        &quot;    \&quot;name\&quot;: \&quot;sk\&quot;,\n&quot; +
                        &quot;    \&quot;pwd\&quot;: \&quot;123\&quot;\n&quot; +
                        &quot;}&quot;,
                ktTest3::class.java
        )
</code></pre>
<blockquote>
<p>-<code>::</code>操作符 ： 创建一个成员引用或者一个类的引用</p>
</blockquote>
<h2 id="扩展函数-抽取utils，全局静态变量"><a href="#扩展函数-抽取utils，全局静态变量" class="headerlink" title="扩展函数(抽取utils，全局静态变量)"></a>扩展函数(抽取utils，全局静态变量)</h2><p>一种可以在不继承父类，也不使用类似装饰器这样的设计模式的情况下对指定类进行扩展的函数</p>
<pre><code class="kotlin">fun &lt;T&gt; ArrayList&lt;T&gt;.test(potion: Int, value: T) {
    this[potion] = value
}
</code></pre>
<blockquote>
<p><code>this</code>关键字作为对应的接受者对象</p>
</blockquote>
<p>现在可以在任意地方调用ArrayList实例的test方法：</p>
<pre><code class="kotlin">        var arrayList = ArrayList&lt;String&gt;()
        arrayList.add(&quot;a&quot;)
        arrayList.add(&quot;c&quot;)
        arrayList.add(&quot;c&quot;)
        arrayList.test(1, &quot;test&quot;)
        println(arrayList[1])
</code></pre>
<blockquote>
<ul>
<li>扩展实际上没有修改它所扩展的类。定义一个扩展，并没有在类中插入一个新的成员，只是让这个类的实例对象能够通过<code>.</code>调用新的函数。 </li>
<li>扩展函数是静态分发的，举个例子,它们并不是接受者类型的虚拟方法。这意味着扩展函数的调用时由发起函数调用的表达式的类型决定的，而不是在运行时动态获得的表达式的类型决定。</li>
</ul>
</blockquote>
<p>for example：</p>
<pre><code class="kotlin">open class C

class D: C()

fun C.foo() = &quot;c&quot;

fun D.foo() = &quot;d&quot;

fun printFoo(c: C) {
    println(c.foo())
}

printFoo(D())  //输出结果为c
</code></pre>
<p>如果有同名同参数的成员函数和扩展函数，调用的时候必然会使用成员函数</p>
<p>比如：</p>
<pre><code class="kotlin">class C {
    fun foo() { println(&quot;member&quot;) }

}
fun C.foo() { println(&quot;extension&quot;) }   //结果输出 member
</code></pre>
<p>如果扩展函数使用重载的方式同名不同参，调用的时候使用扩展函数</p>
<p>比如：</p>
<pre><code class="kotlin">class C {
    fun foo() { println(&quot;number&quot;) }
}

fun C.foo(i:Int) { println(&quot;extention&quot;) }  //调用C().foo(1)输出 extention
</code></pre>
<h2 id="对象表达式和声明-object"><a href="#对象表达式和声明-object" class="headerlink" title="对象表达式和声明(object)"></a>对象表达式和声明(object)</h2><blockquote>
<p>有时候想对一个类做点小修改，又不想声明一个子类。java用匿名内部类解决这个问题，Kotlin 用对象表达式和对象声明实现这一概念</p>
</blockquote>
<h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>使用<code>object</code>可以创建继承自匿名类的对象，比如：</p>
<pre><code class="kotlin">homeChannelAdapter?.setOnItemClickListener(object : HomeChannelAdapter.OnItemClickListener {
    override fun onItemClick(position: Int, advertiseBean: AdvertiseBean) {

    }

})
</code></pre>
<p>如果父类有构造函数，则必须传递相应的构造参数。多个父类可以用逗号隔开，跟在冒号后面：</p>
<pre><code class="kotlin">open class A(x: Int) {
    public open val y: Int = x
}

interface B { ... }

val ab = object : A(1), B {
    override val y = 14
}
</code></pre>
<p>有时只是需要一个没有父类的对象，可以这样写:</p>
<pre><code class="kotlin">val adHoc = object {
    var x: Int = 0
    var y: Int = 0
}

print(adHoc.x + adHoc.y)
</code></pre>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>可以使用关键字<code>object</code>声明一个单例对象，如下：</p>
<pre><code class="kotlin">object SingleClass {
    val a: String = &quot;Str&quot;
    fun toDoing() {
    }

}
</code></pre>
<p>然后就可以直接通过名字访问这个类：</p>
<pre><code class="kotlin">SingleClass.toDoing()
</code></pre>
<p>这样的类型可以有父类:</p>
<pre><code class="kotlin">object SingleClass : KtInterface {
    override val interfaceA: Boolean
        get() = TODO(&quot;not implemented&quot;) //To change initializer of created properties use File | Settings | File Templates.
    override val interfaceB: String
        get() = TODO(&quot;not implemented&quot;) //To change initializer of created properties use File | Settings | File Templates.

    val a: String = &quot;Str&quot;
    fun toDoing() {
    }

}
</code></pre>
<p><strong>注意</strong>：对象声明不可以是局部的(比如不可以直接在函数内部声明)，但可以在其它对象的声明或非内部类中进行内嵌入</p>
<h3 id="伴随对象（全局静态常量）"><a href="#伴随对象（全局静态常量）" class="headerlink" title="伴随对象（全局静态常量）"></a>伴随对象（全局静态常量）</h3><p>在类声明内部可以用 companion 关键字标记对象声明： </p>
<pre><code class="kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre>
<p>伴随对象的成员可以通过类名做限定词直接使用：</p>
<pre><code class="kotlin">val instance = MyClass.create()
</code></pre>
<p>在使用了 companion 关键字时，伴随对象的名字可以省略：</p>
<pre><code class="kotlin">class MyClass {
    companion object {

    }
}
</code></pre>
<h3 id="对象表达式和声明的区别"><a href="#对象表达式和声明的区别" class="headerlink" title="对象表达式和声明的区别"></a>对象表达式和声明的区别</h3><blockquote>
<ul>
<li>对象表达式在我们使用的地方立即初始化并执行的</li>
<li>对象声明是懒加载的，是在我们第一次访问时初始化的。</li>
<li>伴随对象是在对应的类加载时初始化的，和 Java 的静态初始是对应的。</li>
</ul>
</blockquote>
<p></p>




















]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;app开发一个简单的功能，流程基本是： 渲染ui-&amp;gt;请求网路-&amp;gt;解析数据-&amp;gt;设置ui控件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建一个activity&quot;&gt;&lt;a href=&quot;#创建一个activity&quot; class=
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin for android (一)</title>
    <link href="http://yoursite.com/2017/11/13/2017-11-13/"/>
    <id>http://yoursite.com/2017/11/13/2017-11-13/</id>
    <published>2017-11-13T07:54:57.000Z</published>
    <updated>2017-12-06T03:53:06.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>kotlin是现在的android官方语言。它是简洁的，强大的，安全的。与现存的android语言在运行时能够共同使用</p>
</blockquote>
<h2 id="kotlin基础语法"><a href="#kotlin基础语法" class="headerlink" title="kotlin基础语法"></a>kotlin基础语法</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><blockquote>
<p><em>val</em> : 定义一个只读属性<br><em>var</em> : 定义一个可变属性</p>
</blockquote>
<pre><code>val a: Int = 0    //简化 val a = 0  等同于 int a = 0  
val b: Int = a
var c: Byte = 1
var d: Short = 1
var e: Long = 1L
var f: Float = 1.0f
var g: Double = 1.0
var h: Char = &#39;1&#39;
val isBoolean = true
</code></pre><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>-<code>private</code> — 当前类<br>-<code>protected</code> — 当前类和子类<br>-<code>internal</code> — 当前module<br>-<code>public</code> — 默认值，全局</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>kotlin包名可以和路径名不一致，在引入kotlin文件时，以导入的包名为准,默认是 <code>kotlin.*</code></p>
<h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><pre><code class="kotlin">class TestClass {
    private var a: String = &quot;&quot;
}
</code></pre>
<h3 id="构造函数的创建"><a href="#构造函数的创建" class="headerlink" title="构造函数的创建"></a>构造函数的创建</h3><p>kotlin中可以有一个主构造函数和一个或者多个次级构造函数，主构造函数是类头的一部分，一般跟在类名（或者可选的类型参数）后面。</p>
<pre><code class="kotlin">class TestClass constructor(var name: String, var pwd: String) {
}
</code></pre>
<p>如果主构造函数没有任何注解和任何修饰符可以省略<code>constructor</code></p>
<pre><code class="kotlin">class TestClass (var name: String, var pwd: String) {
}
</code></pre>
<p>通过decompile，观察其java实现：</p>
<pre><code class="java">   public TestClass(@NotNull String name, @NotNull String pwd) {
      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);
      Intrinsics.checkParameterIsNotNull(pwd, &quot;pwd&quot;);
      super();
      this.name = name;
      this.pwd = pwd;
   }
</code></pre>
<p>主构造函数不能包含任何逻辑代码，如果要加代码可以写在init方法里，或者写在次级constructor构造函数里</p>
<ul>
<li>方式一 写在<code>init{}</code> 里</li>
</ul>
<pre><code class="kotlin">class TestClass constructor(var name: String, var pwd: String) {
    init {
        println(&quot;$name&quot;)
    }
}
</code></pre>
<ul>
<li>方式二 写在<strong>次级</strong><code>constructor</code> 里</li>
</ul>
<pre><code class="java">    class TestClass {
        private var a: String = &quot;&quot;

        constructor() {

        }

        constructor(a: String) {
            this.a = a
            println(a)
        }
    }
</code></pre>
<p>如果一个类有一个主构造函数，每一个次构造函数必须委托给主构造函数，可以直接委托，或者间接委托，使用<code>this</code>关键字</p>
<pre><code class="kotlin">    class TestClass(var name: String) {
        constructor(name: String, pwd: String) : this(name) {
        }

        constructor(name: String, pwd: String, gender: String) : this(name, pwd) {

        }
    }
</code></pre>
<ul>
<li>如果主构造函数属性修饰为<code>val</code>只读属性，只会生成<code>getter()</code>方法 </li>
<li>如果主构造函属性修饰为<code>var</code>，会生成<code>getter()</code>、<code>setter()</code></li>
<li>如果属性权限使用<code>private</code>或忽略，将不会生成<code>getter()</code>、<code>setter()</code>方法</li>
</ul>
<p></p>

<h3 id="方法的创建"><a href="#方法的创建" class="headerlink" title="方法的创建"></a>方法的创建</h3><p>所有的方法都得带上关键字<code>fun</code>，没个方法都得有返回类，空返回类型是<code>unit</code>，等同于java的<code>void</code>，可以省略</p>
<ul>
<li>有返回类型<ul>
<li>方式一 <pre><code>    fun maxOf(a: Int, b: Int): Int {
      if (a &gt; b) {
          return a
      } else {
          return b
      }
  }
</code></pre></li>
<li>方式二（简化）<pre><code>  fun maxOf2(a: Int, b: Int) = if (a &gt; b) a else b
</code></pre></li>
</ul>
</li>
<li>无返回类型<ul>
<li>方式一   <pre><code>  private fun unitSum(a: Int, b: Int): Unit {
     println(&quot;sum of $a and $b is ${a + b}&quot;)
  }    
</code></pre></li>
<li>方式二             <pre><code>   private fun unitSum(a: Int, b: Int){
     println(&quot;sum of $a and $b is ${a + b}&quot;)
  }
</code></pre></li>
</ul>
</li>
</ul>
<p><em>String 中含有动态的值可以用$加变量名的方式直接写双引号里</em></p>
<h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>判断语句基本和java类似，只是判断的条件表达式有点改进，现在可以使用 <code>==</code> 操作符来判断两个字符串是否相等</p>
<h4 id="范围判断-数值"><a href="#范围判断-数值" class="headerlink" title="范围判断(数值)"></a>范围判断(数值)</h4><p>与 &amp;&amp;</p>
<pre><code>fun useRange() {
    val x = 10
    var y = 9
    y += 1
    if (x in 2..y) {  //等同于 x&gt;=2 &amp;&amp; x&lt;=y
        println(&quot;fits int range&quot;)
    }
}
</code></pre><p>或 ||</p>
<pre><code> fun useRange() {
    val x = 10
    var y = 9
    y += 1
    if (x !in 2..y) {  //等同于 x&lt;2 &amp;&amp; x&gt;y
        println(&quot;fits int range&quot;)
    }
}
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>简单数值类型</p>
<pre><code>fun iterating() {
    for (h in 1.rangeTo(4)) {
        println(h)
    //  Log.e(&quot;TAG&quot;, h.toString())
    }
}
    //rangeTo 升序 输出 1234
</code></pre><p><code>rangeTo</code>可以简写成<code>..</code></p>
<pre><code>fun iterating() {
        for (h in 1..4) {
            println(h)
        //  Log.e(&quot;TAG&quot;, h.toString())
        }
    }
    //rangeTo 升序 输出 1234



fun iterating() {
    for (h in 4.downTo(1)) {
        println(h)
    //  Log.e(&quot;TAG&quot;, h.toString())
    }
}
//downTo 降序序 输出 4321 
</code></pre><p><code>step</code>进阶关键字，根据后面的条件查找当前符合条件的值</p>
<pre><code>fun stepFor() {
    for (y in 1..10 step 3) {
        Log.d(&quot;tag&quot;, y.toString())
    }
}
// 输出1 4 7 10
</code></pre><p>在kotlin中废除了<code>for (初始; 条件; 增减)</code>这个规则；若想实现上述功能，取而代之的，使用<code>for (i in array.indices)</code>语句。 indices为当前的下标数组，每次循环从当前下标开始。 例如：</p>
<pre><code class="kotlin">        for (i in adList.indices) {
                Toast.makeText(mContext, &quot;$i&quot;, Toast.LENGTH_SHORT).show()
            }

        }
</code></pre>
<h3 id="返回与跳出-标记"><a href="#返回与跳出-标记" class="headerlink" title="返回与跳出  (@标记)"></a>返回与跳出  (<code>@</code>标记)</h3><p>和java一样，使用关键字<code>return</code>，<code>break</code>，<code>continue</code>。在多层循环可以使用<code>@</code>标记当前循环体，以便针对此循环体做处理</p>
<pre><code class="kotlin">    fun loopTest() {
        loop@ for (i in 1..100) {
            for (j in 1..100) {
                if (j &gt; 10) {
                    break@loop
                }
                println(&quot;$j&quot;)
            }
            println(&quot;当前是第$i 次&quot;)
        }
        println(&quot;结束了&quot;)
    }
</code></pre>
<p><em>@前面的标记名可以自定义</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;kotlin是现在的android官方语言。它是简洁的，强大的，安全的。与现存的android语言在运行时能够共同使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;kotlin基础语法&quot;&gt;&lt;a href=&quot;#kotlin基础语法&quot; clas
    
    </summary>
    
      <category term="kotlin" scheme="http://yoursite.com/categories/kotlin/"/>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 前缀，中缀，后缀表达式</title>
    <link href="http://yoursite.com/2017/11/03/2017-11-03/"/>
    <id>http://yoursite.com/2017/11/03/2017-11-03/</id>
    <published>2017-11-03T02:54:57.000Z</published>
    <updated>2017-12-07T07:28:54.063Z</updated>
    
    <content type="html"><![CDATA[<p>一般的数学运算表达式都是中缀表达式</p>
<p>中缀  a*(b+c)-d</p>
<p>前缀表达式又称波兰表达式， 其实是树的二叉树前序遍历</p>
<p>也可用栈的处理转换</p>
<p>如上面转换前缀</p>
<p>前缀数逆序读取</p>
<table>
<thead>
<tr>
<th>读取</th>
<th>前缀栈</th>
<th>栈1</th>
</tr>
</thead>
<tbody>
<tr>
<td>  d</td>
<td>d</td>
<td>空</td>
</tr>
<tr>
<td>  -</td>
<td>d</td>
<td>-</td>
</tr>
<tr>
<td>  )</td>
<td>d</td>
<td>-)</td>
</tr>
<tr>
<td>  c</td>
<td>dc</td>
<td>-)</td>
</tr>
<tr>
<td>  +</td>
<td>dc</td>
<td>-)+ </td>
</tr>
<tr>
<td>  b</td>
<td>dcb</td>
<td>-)+ </td>
</tr>
<tr>
<td>  (</td>
<td>dcb+</td>
<td>-  双括号匹配抵消外侧操作符出栈</td>
</tr>
<tr>
<td>  *</td>
<td>dcb+</td>
<td>-* 加入的操作符&gt;=入栈，否则大的操作符出栈 </td>
</tr>
<tr>
<td>  a</td>
<td>dcb+a</td>
<td>-* \</td>
</tr>
<tr>
<td></td>
<td>dcb+a*-</td>
<td>-* 出栈</td>
</tr>
</tbody>
</table>
<p>逆序输出  -*a+bcd</p>
<p>后缀数正序读取</p>
<table>
<thead>
<tr>
<th>读取</th>
<th>后缀栈</th>
<th>栈1</th>
</tr>
</thead>
<tbody>
<tr>
<td>  a</td>
<td>a</td>
<td>空</td>
</tr>
<tr>
<td>  *</td>
<td>a</td>
<td>*</td>
</tr>
<tr>
<td>  (</td>
<td>a</td>
<td>*(</td>
</tr>
<tr>
<td>  b</td>
<td>ab</td>
<td>*(</td>
</tr>
<tr>
<td>  +</td>
<td>ab</td>
<td>*(+ </td>
</tr>
<tr>
<td>  c</td>
<td>abc</td>
<td>*(+</td>
</tr>
<tr>
<td>  )</td>
<td>abc+</td>
<td>*  双括号匹配抵消内侧操作符出栈</td>
</tr>
<tr>
<td>  -</td>
<td>abc+</td>
<td>*  加入的操作符&gt;=入栈，否则大的操作符出栈,直到小于，小的入栈 </td>
</tr>
<tr>
<td>  d</td>
<td>abc+*d</td>
<td>- </td>
</tr>
<tr>
<td>结束</td>
<td>abc+*d-</td>
<td>- 出栈</td>
</tr>
</tbody>
</table>
<p>正序输出  abc+*d- </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的数学运算表达式都是中缀表达式&lt;/p&gt;
&lt;p&gt;中缀  a*(b+c)-d&lt;/p&gt;
&lt;p&gt;前缀表达式又称波兰表达式， 其实是树的二叉树前序遍历&lt;/p&gt;
&lt;p&gt;也可用栈的处理转换&lt;/p&gt;
&lt;p&gt;如上面转换前缀&lt;/p&gt;
&lt;p&gt;前缀数逆序读取&lt;/p&gt;
&lt;table&gt;
&lt;thea
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>微信调用返回的坑</title>
    <link href="http://yoursite.com/2017/09/28/2017-09-28/"/>
    <id>http://yoursite.com/2017/09/28/2017-09-28/</id>
    <published>2017-09-28T06:48:57.000Z</published>
    <updated>2017-09-28T07:06:39.592Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做微信分享的时候，发现进入分享界面，什么都不做，直接返回，会有个微信的透明遮罩界面，得再返回一次就ok，通过调试，定位分析。最终查出问题所在：</p>
<p>微信的WXEntryActivity类，必须得实现<code>oncrete()</code>方法，否则不会进入回调方法 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在做微信分享的时候，发现进入分享界面，什么都不做，直接返回，会有个微信的透明遮罩界面，得再返回一次就ok，通过调试，定位分析。最终查出问题所在：&lt;/p&gt;
&lt;p&gt;微信的WXEntryActivity类，必须得实现&lt;code&gt;oncrete()&lt;/code&gt;方法，否则不会进
    
    </summary>
    
      <category term="wechat" scheme="http://yoursite.com/categories/wechat/"/>
    
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用DayNight主题和webview的冲突</title>
    <link href="http://yoursite.com/2017/09/26/2017-09-26/"/>
    <id>http://yoursite.com/2017/09/26/2017-09-26/</id>
    <published>2017-09-26T02:47:57.000Z</published>
    <updated>2017-12-05T10:25:19.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这几天在使用DayNight主题的时候碰到一个坑,看官方的介绍是WebView用DayNight主题无效，且会有一些适配啥的问题，但是并没有明确什么问题。而当我用webview + DayNight theme的时候，发现当前webview所在的activity每次初次打开会重绘一次。如果里面有请求且用了注解，会找不到view的id而崩溃</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经过调试，发现daynight主题只有含有webview的activity才会重绘一次。而重绘之后上一次初始化的activity的信息会被带到oncreate的Bundle里</p>
<pre><code>protected void onCreate(@Nullable Bundle savedInstanceState)
</code></pre><p>而第一次初始化的activity会执行onDestroy()</p>
<p>所以目前有两种方案：</p>
<p>1.在回调地方这样判断</p>
<pre><code class="java">if (this == null || this.isDestroyed()) {
return;
}
</code></pre>
<p><strong>注意</strong>  <em>isDestroyed()是sdk 17以后才有的方法</em></p>
<p>2.强制不重绘，在manifast找到相应的activity加上以下属性</p>
<pre><code> android:configChanges=&quot;uiMode&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;这几天在使用DayNight主题的时候碰到一个坑,看官方的介绍是WebView用DayNight主题无效，且会有一些适配啥的问题，但是并没有
    
    </summary>
    
      <category term="DayNight" scheme="http://yoursite.com/categories/DayNight/"/>
    
    
      <category term="DayNight" scheme="http://yoursite.com/tags/DayNight/"/>
    
  </entry>
  
  <entry>
    <title>android imageview scaleType 和 adjustViewBounds</title>
    <link href="http://yoursite.com/2017/08/07/android-imageview-scaleType/"/>
    <id>http://yoursite.com/2017/08/07/android-imageview-scaleType/</id>
    <published>2017-08-07T02:47:57.000Z</published>
    <updated>2017-08-07T09:59:39.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>之前在用imageloader，glide等图片加载框架加载图片时，很喜欢给imageview设的几个属性是</p>
<pre><code>        android:scaleType=&quot;fitXY&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
</code></pre><p>这样可以在不同手机上显示原图的大小，特别是一些小图标的显示，这样做，按照高分辨率兼容低分率的情况可以不用管适配问题。</p>
<p>但是最近在项目里遇到一个问题，如果是一张超过部分手机分辨率的的大图，或者当前图片的宽高已然超过手机宽高，图片会变形。 即使设置<code>android:layout_width=&quot;match_parent&quot;</code>也一样</p>
<p>先来看下scaletype的几个属性，样例imageview宽高都是match_parent</p>
<h2 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h2><p><img src="/images/scale_type/fit_xy_adjustViewBounds.png" alt="&quot;加了adjustViewBounds&quot;"></p>
<h2 id="FIT-XY"><a href="#FIT-XY" class="headerlink" title="FIT_XY"></a>FIT_XY</h2><blockquote>
<p>Scale the image using FILL. </p>
</blockquote>
<p>把原图按照imageview的指定大小拉伸缩放图片，不按照比例。</p>
<p><img src="/images/scale_type/fit_xy.png" alt="fit_xy"></p>
<h2 id="CENTER"><a href="#CENTER" class="headerlink" title="CENTER"></a>CENTER</h2><blockquote>
<p>Center the image in the view, but perform no scaling.</p>
</blockquote>
<p>保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。</p>
<p><img src="/images/scale_type/center.png" alt="fit_center"></p>
<h2 id="CENTER-CROP"><a href="#CENTER-CROP" class="headerlink" title="CENTER_CROP"></a>CENTER_CROP</h2><blockquote>
<p>Scale the image uniformly (maintain the image’s aspect ratio) so that both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding).</p>
</blockquote>
<p>以填满整个ImageView为目的，将原图的中心对准ImageView的中心，等比例放大原图，直到填满ImageView为止（指的是ImageView的宽和高都要填满），原图超过ImageView的部分作裁剪处理 </p>
<p><img src="/images/scale_type/center_crop.png" alt="CENTER_CROP"></p>
<h2 id="CENTER-INSIDE"><a href="#CENTER-INSIDE" class="headerlink" title="CENTER_INSIDE"></a>CENTER_INSIDE</h2><blockquote>
<p>Scale the image uniformly (maintain the image’s aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding). </p>
</blockquote>
<p>以原图完全显示为目的，将图片的内容完整居中显示，通过按比例缩小原图的size宽(高)等于或小于ImageView的宽(高)。如果原图的size本身就小于ImageView的size，则原图的size不作任何处理，居中显示在ImageView。</p>
<p><img src="/images/scale_type/center_inside.png" alt="CENTER_INSIDE"></p>
<h2 id="FIT-CENTER"><a href="#FIT-CENTER" class="headerlink" title="FIT_CENTER"></a>FIT_CENTER</h2><blockquote>
<p>Scale the image using CENTER. </p>
</blockquote>
<p>把原图按比例扩大或缩小到ImageView的高度，居中显示</p>
<p><img src="/images/scale_type/fit_center.png" alt="FIT_CENTER"></p>
<h2 id="FIT-START"><a href="#FIT-START" class="headerlink" title="FIT_START"></a>FIT_START</h2><blockquote>
<p>Scale the image using START. </p>
</blockquote>
<p>把原图按比例扩大(缩小)到ImageView的高度，显示在ImageView的上部分位置</p>
<p><img src="/images/scale_type/fit_start.png" alt="FIT_START"></p>
<h2 id="FIT-END"><a href="#FIT-END" class="headerlink" title="FIT_END"></a>FIT_END</h2><blockquote>
<p>Scale the image using END.</p>
</blockquote>
<p>把原图按比例扩大(缩小)到ImageView的高度，显示在ImageView的下部分位置 </p>
<p><img src="/images/scale_type/fit_end.png" alt="FIT_END"></p>
<h2 id="MATRIX"><a href="#MATRIX" class="headerlink" title="MATRIX"></a>MATRIX</h2><blockquote>
<p>Scale using the image matrix when drawing. </p>
</blockquote>
<p>不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理。</p>
<p><img src="/images/scale_type/matrix.png" alt="MATRIX"></p>
<h2 id="adjustViewBounds"><a href="#adjustViewBounds" class="headerlink" title="adjustViewBounds"></a>adjustViewBounds</h2><blockquote>
<p>Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable.</p>
<p>Note: If the application targets API level 17 or lower, adjustViewBounds will allow the drawable to shrink the view bounds, but not grow to fill available measured space in all cases. This is for compatibility with legacy MeasureSpec and RelativeLayout behavior.</p>
</blockquote>
<p>如果设置为true，允许imageview调整边界保持长宽比。 </p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>加一个属性保持缩放比<code>android:adjustViewBounds=&quot;true&quot;</code>就好了</p>
<p>增加adjustViewBounds前<br><img src="/images/scale_type/fit_xy_not_adjustViewBounds.png" alt="&quot;没加adjustViewBounds&quot;"></p>
<p>增加adjustViewBounds后<br><img src="/images/scale_type/fit_xy_adjustViewBounds.png" alt="&quot;加了adjustViewBounds&quot;"></p>
<p>查阅资料，网上的说法是增加adjustViewBounds前不能单独使用，需要配合maxWidth或maxHeight一起使用。但是测试下来直接设置是有效的。 目前没有试上面说的targets 17以下的机型。</p>
<p>然后稍微看了下源码</p>
<pre><code class="java">   public void setAdjustViewBounds(boolean adjustViewBounds) {
        mAdjustViewBounds = adjustViewBounds;
        if (adjustViewBounds) {
            setScaleType(ScaleType.FIT_CENTER);
        }
    }
</code></pre>
<p>设置adjustViewBounds，会改变scaletype为fitcenter，当imageview的宽高小于等于图片宽高时，fitcenter和fitxy+AdjustViewBounds 效果类似，但是imageview的宽高大于图片宽高时，fitcenter会居中缩放显示，fitxy+AdjustViewBounds会从上面缩放显示</p>
<p>关于这个adjustViewBounds感觉还是得抽时间撸撸源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;之前在用imageloader，glide等图片加载框架加载图片时，很喜欢给imageview设的几个属性是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    
    </summary>
    
    
      <category term="scaleType;adjustViewBounds" scheme="http://yoursite.com/tags/scaleType-adjustViewBounds/"/>
    
  </entry>
  
  <entry>
    <title>使用调试神器stetho碰到的一些问题</title>
    <link href="http://yoursite.com/2017/07/12/stetho-develop/"/>
    <id>http://yoursite.com/2017/07/12/stetho-develop/</id>
    <published>2017-07-12T07:58:06.000Z</published>
    <updated>2017-07-12T08:19:47.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul>
<li>Android 4.4 开始，默认的浏览器已经是 chrome 了，所以 webview 也是 chrome 了，这就给了 webview 远程调试的能力。我们需要在 Android 里针对 Webview 做以下设置：<pre><code>  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
              WebView.setWebContentsDebuggingEnabled(true);
         }
</code></pre></li>
<li>打正式的混淆包有可能会碰到监听不了网络的情况，此时需要在Proguard里配置 <pre><code>  -keep class com.facebook.stetho.** { *; }  
  -dontwarn org.mozilla.javascript.**  
  -dontwarn org.mozilla.classfile.**  
  -keep class org.mozilla.javascript.** { *; } 
</code></pre></li>
<li>chrome远程调试按inspect后出现的界面为空白，应如何解决？ <ol>
<li>因为chrome inspect需要加载 <a href="https://chrome-devtools-frontend.appspot.com" target="_blank" rel="external">https://chrome-devtools-frontend.appspot.com</a> 上的资源，所以需要翻墙。</li>
<li>chrome://appcache-internals/# -&gt; remove cache -&gt; enjoy it</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题汇总&quot;&gt;&lt;a href=&quot;#问题汇总&quot; class=&quot;headerlink&quot; title=&quot;问题汇总&quot;&gt;&lt;/a&gt;问题汇总&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Android 4.4 开始，默认的浏览器已经是 chrome 了，所以 webview 也是 chrome 了
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>入坑hexo独立博客</title>
    <link href="http://yoursite.com/2017/07/04/create-hexo-blog/"/>
    <id>http://yoursite.com/2017/07/04/create-hexo-blog/</id>
    <published>2017-07-04T10:00:36.000Z</published>
    <updated>2017-07-05T10:58:26.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo文档</a>, 有能力直接看英文。</p>
<p><img src="/images/1435051044_500x500.png" alt=""></p>
<h2 id="关联github"><a href="#关联github" class="headerlink" title="关联github"></a>关联github</h2><p>在github上创建一个页面仓库，仓库名需要和账号对应， 格式为: yourname.github.io</p>
<p><img src="/images/git_name.png" alt=""></p>
<p><em>注意命名规则 : <code>xxx.github.io</code></em></p>
<h2 id="全局配置-config-yml"><a href="#全局配置-config-yml" class="headerlink" title="全局配置_config.yml"></a>全局配置_config.yml</h2><p>到了这里应该是hexo的工程已经创建完毕了，在之前<code>hexo init</code>创建的根目录。打开后在最下面的deploy节点添加一个repo和branch。</p>
<pre><code>deploy:
  type: git
  repo: 刚才创建的仓库地址.git
  branch: master
</code></pre><ul>
<li>repo: 刚刚github创库地址.git，如xxx.github.io.git</li>
<li>配置里所有的冒号后面得有一个空格</li>
</ul>
<h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><p>依次执行下列执行完成部署</p>
<pre><code class="cmd">hexo g
hexo d
</code></pre>
<p>此时可能会碰到<code>Deployer not found: git</code>的问题</p>
<p>执行</p>
<pre><code class="cmd">npm install hexo-deployer-git --save
</code></pre>
<p>重新deploy，等待命令窗执行</p>
<p>出现<code>INFO  Deploy done: git</code>即部署成功</p>
<p>点击 Github 上项目的 Settings，滑动到GitHub Pages，提示Your site is published at xxx.github.io</p>
<p>到了这一步，你可以使用xxx.github.io访问刚才部署的hexo静态网站</p>
<h2 id="映射绑定独立域名"><a href="#映射绑定独立域名" class="headerlink" title="映射绑定独立域名"></a>映射绑定独立域名</h2><h2 id="修改github-page-domain"><a href="#修改github-page-domain" class="headerlink" title="修改github page domain"></a>修改github page domain</h2><p>在刚才的setting里 , Custom domain 修改为买的域名。</p>
<h2 id="将域名绑定Github-Page的空间"><a href="#将域名绑定Github-Page的空间" class="headerlink" title="将域名绑定Github Page的空间"></a>将域名绑定Github Page的空间</h2><blockquote>
<p>方法一：在之前用hexo创建项目的source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如 iskay.me</p>
<p>方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，不要后缀名。里面写入你要绑定的域名, 如 iskay.me</p>
</blockquote>
<p>这里我使用的是第一种，到时候使用hexo命令部署会自动提交到远程仓库</p>
<h2 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h2><p>使用<a href="https://www.dnspod.cn" target="_blank" rel="external">DNSPod</a>, 先注册dnspod，然后添加域名，让他自动添加后如下图</p>
<p><img src="/images/97L38ZX(09JXA08RD{2LJUA.png" alt="域名"></p>
<p>修改A 类型的记录值，改为github.io的ip，进入cmd ，ping <code>yourname.github.io</code>，得到ip复制进去。<br>修改 CNAME的记录值，改为你的github page的域名 <code>yourname.github.io</code>。<br>去你买域名的网站修改dns，改为记录类型为NS的那两个，保存</p>
<p>好了，等待吧。 也许半小时，也许几小时，等待云刷新。<br>然后，可以使用你的域名开心玩耍了</p>
<h2 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h2><p><a href="http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客</a><br><a href="http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/" target="_blank" rel="external">手把手教你建github技术博客by hexo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前戏&quot;&gt;&lt;a href=&quot;#前戏&quot; class=&quot;headerlink&quot; title=&quot;前戏&quot;&gt;&lt;/a&gt;前戏&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署问题</title>
    <link href="http://yoursite.com/2017/07/04/hexo-Error/"/>
    <id>http://yoursite.com/2017/07/04/hexo-Error/</id>
    <published>2017-07-04T06:16:42.000Z</published>
    <updated>2017-07-04T06:38:15.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>cmd下执行<code>hexo d</code>时报错</p>
<pre><code>Error: spawn git ENOENT
    at exports._errnoException (util.js:746:11)
    at Process.ChildProcess._handle.onexit (child_process.js:1053:32)
    at child_process.js:1144:20
    at process._tickCallback (node.js:355:11)
</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>把git的环境变量添加到path里去重启下cmd，就ok了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;cmd下执行&lt;code&gt;hexo d&lt;/code&gt;时报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: spawn git E
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
